from reportlab.lib import colors
from reportlab.graphics.shapes import (
    Drawing, Line, PolyLine, String, Group,
    mmult, translate, rotate
)
from reportlab.graphics import testshapes
from reportlab.graphics.shapes import Rect
from reportlab.lib.colors import red, green
from reportlab.pdfbase import pdfmetrics
from reportlab import rl_config

from utils import (
    heading1,
    cn_heading1,
    heading2,
    cn_heading2,
    heading3,
    cn_heading3,
    heading4,
    cn_heading4,
    disc,
    cn_disc,
    eg,
    cn_eg,
    illust,
    cn_illust,
    CPage,
    parabox,
    parabox2,
    bullet,
    cn_bullet,
    getStory,
    pencilnote,
    startKeep,
    endKeep,
    caption,
    cn_caption,
    styleSheet,
    cn_styleSheet,
    draw,
    cn_draw,
    getJustFontPaths,
)


# heading2("Shapes")
cn_heading2("多边形")

disc(
    """
This section describes the concept of shapes and their importance
as building blocks for all output generated by the graphics library.
Some properties of existing shapes and their relationship to
diagrams are presented and the notion of having different renderers
for different output formats is briefly introduced.
"""
)
cn_disc('本节介绍形状的概念及其作为图形库生成的所有输出的构建块的重要性。 '
        '介绍了现有形状的一些属性及其与图表的关系，'
        '并简要介绍了针对不同输出格式使用不同渲染器的概念。')


heading3("Available Shapes")
cn_heading3('可用形状')

disc(
    """
Drawings are made up of Shapes. Absolutely anything can be built up by 
combining the same set of
primitive shapes. The module $shapes.py$ supplies a number of primitive 
shapes and constructs which can be added to a drawing. They are:
"""
)
cn_disc('绘画是由形状组成的。任何东西都可以通过组合相同的原始图形集来构建。'
        '模块$shapes.py$提供了一些可以添加到图形中的基本形状和构造。它们是')


bullet("Rect - 矩形")
bullet("Circle - 圆")
bullet("Ellipse - 椭圆")
bullet("Wedge (a pie slice) - 扇形")
bullet("Polygon - 多边形")
bullet("Line - 线")
bullet("PolyLine - 折线")
bullet("String - 字符串")
bullet("Group - 组")
# bullet("Path (<i>not implemented yet, but will be added in the future</i>)")
cn_bullet("$Path$ (<i>还没有完全实现，但将来会加入</i>) - 路径")

disc(
    """
The following drawing, taken from our test suite, shows most of the
basic shapes (except for groups).
Those with a filled green surface are also called <i>solid shapes</i>
(these are $Rect$, $Circle$, $Ellipse$, $Wedge$ and $Polygon$).
"""
)
cn_disc('下面的图画来自于我们的测试套件，显示了大部分的基本形状（除了组）。那些有绿色填充面的图形也被称为<i>实体图形</i>。'
        '(这些是$Rect$、$Circle$、$Ellipse$、$Wedge$和$Polygon$)。')


t = testshapes.getDrawing06()
# draw(t, "Basic shapes")
cn_draw(t, '基本的图形')

# heading3("Shape Properties")
cn_heading3('形状属性')

disc(
    """
Shapes have two kinds of properties - some to define their geometry
and some to define their style.
Let's create a red rectangle with 3-point thick green borders:
"""
)
cn_disc('形状有两种属性 --有的用来定义其几何形状，'
        '有的用来定义其样式。让我们创建一个红色的矩形，有3点粗的绿色边框。')


eg(
    """
>>> from reportlab.graphics.shapes import Rect
>>> from reportlab.lib.colors import red, green
>>> r = Rect(5, 5, 200, 100)
>>> r.fillColor = red
>>> r.strokeColor = green
>>> r.strokeWidth = 3
>>>
""")



d = Drawing(220, 120)
r = Rect(5, 5, 200, 100)
r.fillColor = red
r.strokeColor = green
r.strokeWidth = 3
d.add(r)
# draw(d, "red rectangle with green border")
cn_draw(d, '红色矩形和绿色边框')

disc(
    """
<i>Note: In future examples we will omit the import statements.</i>
"""
)
cn_disc('<i><font color="red">注意</font>：在未来的例子中，我们将省略导入语句。</i>')


disc(
    """
All shapes have a number of properties which can be set.
At an interactive prompt, we can use their <i>dumpProperties()</i>
method to list these. Here's what you can use to configure a Rect:
"""
)
cn_disc('所有的形状都有一些可以设置的属性。'
        '在交互式提示下，我们可以使用它们的<i>$dumpProperties()$</i>方法来列出这些属性。'
        '下面是你可以用来配置一个Rect.Rex的方法。')


eg(
    """
>>> r.dumpProperties()
fillColor = Color(1.00,0.00,0.00)
height = 100
rx = 0
ry = 0
strokeColor = Color(0.00,0.50,0.00)
strokeDashArray = None
strokeLineCap = 0
strokeLineJoin = 0
strokeMiterLimit = 0
strokeWidth = 3
width = 200
x = 5
y = 5
>>>
"""
)

disc(
    """
Shapes generally have <i>style properties</i> and <i>geometry
properties</i>.
$x$, $y$, $width$ and $height$ are part of the geometry and must
be provided when creating the rectangle, since it does not make
much sense without those properties.
The others are optional and come with sensible defaults.
"""
)
cn_disc('形状一般有<i>style属性</i>和<i>geometry属性</i>。'
        '$x$, $y$, $width$ 和 $height$ 是几何属性的一部分，'
        '在创建矩形时必须提供，因为没有这些属性就没有什么意义。'
        '其他的属性是可选的，并且有合理的默认值。')


disc(
    """
You may set other properties on subsequent lines, or by passing them
as optional arguments to the constructor.
We could also have created our rectangle this way:
"""
)
cn_disc('你可以在随后的行中设置其他属性，或者将它们作为可选参数传递给构造函数。'
        '我们也可以用这种方式来创建我们的矩形。')


eg(
    """
>>> r = Rect(5, 5, 200, 100,
             fillColor=red,
             strokeColor=green,
             strokeWidth=3)
"""
)

disc(
    """
Let's run through the style properties. $fillColor$ is obvious.
$stroke$ is publishing terminology for the edge of a shape;
the stroke has a color, width, possibly a dash pattern, and
some (rarely used) features for what happens when a line turns
a corner. $rx$ and $ry$ are optional geometric properties and are used to
define the corner radius for a rounded rectangle.
"""
)
cn_disc('我们来看看样式属性。'
        '$fillColor$是显而易见的。'
        '$stroke$ 是形状边缘的发布术语；$stroke$有一个颜色、宽度，'
        '可能还有一个破折号图案，以及一些（很少使用的）功能，'
        '用于当一条线转角时发生的情况。'
        '$rx$ 和 $ry$ 是可选的几何属性，用于定义圆角矩形的角半径。')


disc("All the other solid shapes share the same style properties.")
cn_disc('其他所有的实体形状都具有相同的样式属性。')


# heading3("Lines")
cn_heading3('线')

disc(
    """
We provide single straight lines, PolyLines and curves.
Lines have all the $stroke*$ properties, but no $fillColor$.
Here are a few Line and PolyLine examples and the corresponding
graphics output:
"""
)
cn_disc('我们提供单条直线、多条直线和曲线。'
        '线条具有所有的$stroke*$属性，但没有$fillColor$。'
        '下面是一些直线和多线的例子以及相应的图形输出。')

eg(
    """
    Line(50,50, 300,100,
         strokeColor=colors.blue, strokeWidth=5)
    Line(50,100, 300,50,
         strokeColor=colors.red,
         strokeWidth=10,
         strokeDashArray=[10, 20])
    PolyLine([120,110, 130,150, 140,110, 150,150, 160,110,
              170,150, 180,110, 190,150, 200,110],
             strokeWidth=2,
             strokeColor=colors.purple)
"""
)

d = Drawing(400, 200)
d.add(Line(50, 50, 300, 100, strokeColor=colors.blue, strokeWidth=5))
d.add(
    Line(
        50,
        100,
        300,
        50,
        strokeColor=colors.red,
        strokeWidth=10,
        strokeDashArray=[10, 20],
    )
)
d.add(
    PolyLine(
        [
            120,
            110,
            130,
            150,
            140,
            110,
            150,
            150,
            160,
            110,
            170,
            150,
            180,
            110,
            190,
            150,
            200,
            110,
        ],
        strokeWidth=2,
        strokeColor=colors.purple,
    )
)
# draw(d, "Line and PolyLine examples")
cn_draw(d, "线型和多线型示例")

# heading3("Strings")
cn_heading3('字符串')

disc(
    """
The ReportLab Graphics package is not designed for fancy text
layout, but it can place strings at desired locations and with
left/right/center alignment.
Let's specify a $String$ object and look at its properties:
"""
)
cn_disc('$ReportLab$ 图形包并不是为花哨的文本布局而设计的，'
        '但它可以将字符串放置在所需的位置上，'
        '并进行 $left/right/center$ 对齐。'
        '让我们指定一个$String$对象，看看它的属性。')


eg(
    """
>>> s = String(10, 50, 'Hello World')
>>> s.dumpProperties()
fillColor = Color(0.00,0.00,0.00)
fontName = Times-Roman
fontSize = 10
text = Hello World
textAnchor = start
x = 10
y = 50
>>>
"""
)

disc(
    """
Strings have a textAnchor property, which may have one of the
values 'start', 'middle', 'end'. If this is set to 'start', x and y relate to the start of the
string, and so on. This provides an easy way to align text.
"""
)
cn_disc("字符串有一个 $textAnchor$ 属性，它的值可以是 $'start'$、$'middle'$、$'end'$之一。"
        "如果设置为$'start'$，则 x 和  y与字符串的开始相关，以此类推。"
        "这提供了一个简单的方法来对齐文本。")


disc(
    """
Strings use a common font standard: the Type 1 Postscript fonts
present in Acrobat Reader. We can thus use the basic 14 fonts in ReportLab 
and get accurate metrics for them. We have recently also added support for 
extra Type 1 fonts and the renderers all know how to render Type 1 fonts.
"""
)
cn_disc('字符串使用一个通用的字体标准：$Acrobat Reader$ 中存在的 $Type 1 Postscript$ 字体。'
        '因此，我们可以在 $ReportLab$ 中使用基本的14种字体，并获得准确的指标。'
        '我们最近还增加了对额外的$Type 1$字体的支持，'
        '渲染器都知道如何渲染$Type 1$字体。')


##Until now we have worked with bitmap renderers which have to use
##TrueType fonts and which make some substitutions; this could lead
##to differences in text wrapping or even the number of labels on
##a chart between renderers.

disc(
    """
Here is a more fancy example using the code snippet below.
Please consult the ReportLab User Guide to see how non-standard
like 'DarkGardenMK' fonts are being registered!
"""
)
cn_disc("下面是一个使用下面代码片段的更漂亮的例子。"
        "请查阅 $ReportLab$ 用户指南，了解像 $'DarkGardenMK'$ 这样的非标准字体是如何被注册的。")


eg(
    """
    d = Drawing(400, 200)
    for size in range(12, 36, 4):
        d.add(String(10+size*2, 10+size*2, 'Hello World',
                     fontName='Times-Roman',
                     fontSize=size))

    d.add(String(130, 120, 'Hello World',
                 fontName='Courier',
                 fontSize=36))

    d.add(String(150, 160, 'Hello World',
                 fontName='DarkGardenMK',
                 fontSize=36))
"""
)


rl_config.warnOnMissingFontGlyphs = 0
afmFile, pfbFile = getJustFontPaths()
T1face = pdfmetrics.EmbeddedType1Face(afmFile, pfbFile)
T1faceName = 'DarkGardenMK'
pdfmetrics.registerTypeFace(T1face)
T1font = pdfmetrics.Font(T1faceName, T1faceName, 'WinAnsiEncoding')
pdfmetrics.registerFont(T1font)

d = Drawing(400, 200)
for size in range(12, 36, 4):
    d.add(
        String(
            10 + size * 2,
            10 + size * 2,
            'Hello World',
            fontName='Times-Roman',
            fontSize=size,
        )
    )

d.add(String(130, 120, 'Hello World', fontName='Courier', fontSize=36))

d.add(String(150, 160, 'Hello World', fontName='DarkGardenMK', fontSize=36))

# draw(d, 'fancy font example')
cn_draw(d, '花式字体样例')

# heading3("""Paths""")
cn_heading3('$Paths$')

disc(
    """
Postscript paths are a widely understood concept in graphics.
They are not implemented in $reportlab/graphics$ as yet, but they
will be, soon.
"""
)
cn_disc('$Postscript paths$ 是图形学中一个广为人知的概念。'
        '它们在$reportlab/graphics$中还没有实现，但很快就会实现。')


# NB This commented out section is for 'future compatibility' - paths haven't
#    been implemented yet, but when they are we can uncomment this back in.

##disc("""Postscript paths are a widely understood concept in graphics. A Path
##       is a way of defining a region in space. You put an imaginary pen down,
##       draw straight and curved segments, and even pick the pen up and move
##       it. At the end of this you have described a region, which may consist
##       of several distinct close shapes or unclosed lines. At the end, this
##       'path' is 'stroked and filled' according to its properties. A Path has
##       the same style properties as a solid shape. It can be used to create
##       any irregular shape.""")
##
##disc("""In Postscript-based imaging models such as PDF, Postscript and SVG,
##       everything is done with paths. All the specific shapes covered above
##       are instances of paths; even text strings (which are shapes in which
##       each character is an outline to be filled). Here we begin creating a
##       path with a straight line and a bezier curve:""")
##
##eg("""
##>>> P = Path(0,0, strokeWidth=3, strokeColor=red)
##>>> P.lineTo(0, 50)
##>>> P.curveTo(10,50,80,80,100,30)
##>>>
##""")

##disc("""As well as being the only way to draw complex shapes, paths offer some
##       performance advantages in renderers which support them. If you want to
##       create a scatter plot with 5000 blue circles of different sizes, you
##       can create 5000 circles, or one path object. With the latter, you only
##       need to set the color and line width once. PINGO just remembers the
##       drawing sequence, and writes it out into the file. In renderers which
##       do not support paths, the renderer will still have to decompose it
##       into 5000 circles so you won't save anything.""")
##
##disc("""<b>Note that our current path implementation is an approximation; it
##         should be finished off accurately for PDF and PS.</b>""")


# heading3("Groups")
cn_heading3('$Groups$')

disc(
    """
Finally, we have Group objects. A group has a list of contents, which are 
other nodes. It can also apply a transformation - its contents can be rotated,
scaled or shifted. If you know the math, you can set the transform directly.
Otherwise it provides methods to rotate, scale and so on. Here we make a 
group which is rotated and translated:
"""
)
cn_disc('最后，我们有 $Group$ 对象。'
        '一个组有一个内容列表，就是其他节点。'
        '它还可以应用变换 -- 它的内容可以被旋转、缩放或移动。'
        '如果你懂数学，你可以直接设置变换。'
        '否则它提供了旋转、缩放等方法。'
        '在这里，我们做一个旋转和转换的组。')


eg(
    """
>>> g =Group(shape1, shape2, shape3)
>>> g.rotate(30)
>>> g.translate(50, 200)
"""
)

disc(
    """
Groups provide a tool for reuse. You can make a bunch of shapes to represent 
some component - say, a coordinate system - and put them in one group called 
"Axis". You can then put that group into other groups, each with a different
translation and rotation, and you get a bunch of axis.
It is still the same group, being drawn in different places.
"""
)
cn_disc('组提供了一个重复使用的工具。'
        '你可以做一堆形状来表示某个组件 '
        '--比如说，一个坐标系--并把它们放在一个叫做 "Axis" (轴) 的组里。'
        '然后你可以把这个组放到其他组中，每个组都有不同的平移和旋转，'
        '你就会得到一堆轴。它仍然是同一个组，被画在不同的地方。')


disc("""Let's do this with some only slightly more code:""")
cn_disc('让我们用一些只稍微多一点的代码来做这件事。')


eg(
    """
    d = Drawing(400, 200)

    Axis = Group(
        Line(0,0,100,0),  # x axis
        Line(0,0,0,50),   # y axis
        Line(0,10,10,10), # ticks on y axis
        Line(0,20,10,20),
        Line(0,30,10,30),
        Line(0,40,10,40),
        Line(10,0,10,10), # ticks on x axis
        Line(20,0,20,10),
        Line(30,0,30,10),
        Line(40,0,40,10),
        Line(50,0,50,10),
        Line(60,0,60,10),
        Line(70,0,70,10),
        Line(80,0,80,10),
        Line(90,0,90,10),
        String(20, 35, 'Axes', fill=colors.black)
        )

    firstAxisGroup = Group(Axis)
    firstAxisGroup.translate(10,10)
    d.add(firstAxisGroup)

    secondAxisGroup = Group(Axis)
    secondAxisGroup.translate(150,10)
    secondAxisGroup.rotate(15)

    d.add(secondAxisGroup)

    thirdAxisGroup = Group(Axis,
                           transform=mmult(translate(300,10),
                                           rotate(30)))
    d.add(thirdAxisGroup)
"""
)

d = Drawing(400, 200)
Axis = Group(
    Line(0, 0, 100, 0),  # x axis
    Line(0, 0, 0, 50),  # y axis
    Line(0, 10, 10, 10),  # ticks on y axis
    Line(0, 20, 10, 20),
    Line(0, 30, 10, 30),
    Line(0, 40, 10, 40),
    Line(10, 0, 10, 10),  # ticks on x axis
    Line(20, 0, 20, 10),
    Line(30, 0, 30, 10),
    Line(40, 0, 40, 10),
    Line(50, 0, 50, 10),
    Line(60, 0, 60, 10),
    Line(70, 0, 70, 10),
    Line(80, 0, 80, 10),
    Line(90, 0, 90, 10),
    String(20, 35, 'Axes', fill=colors.black),
)
firstAxisGroup = Group(Axis)
firstAxisGroup.translate(10, 10)
d.add(firstAxisGroup)
secondAxisGroup = Group(Axis)
secondAxisGroup.translate(150, 10)
secondAxisGroup.rotate(15)
d.add(secondAxisGroup)
thirdAxisGroup = Group(Axis, transform=mmult(translate(300, 10), rotate(30)))
d.add(thirdAxisGroup)
# draw(d, "Groups examples")
cn_draw(d, "$Groups$ 示例")
